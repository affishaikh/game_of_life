{"version":3,"sources":["models/gameOfLifeUtils.js","Grid.js","models/gameOfLife.js","index.js"],"names":["module","exports","zipper","yCoordinates","result","element","index","length","push","validateNeighbours","bounds","neighbour","startPoint","topLeft","endPopint","bottomRight","isValid","contains","currentGeneration","some","cell","Data","props","rowIndex","columnIndex","react_default","a","createElement","className","id","Row","row","map","Grid_Data","Body","grid","Grid_Row","Table","onClick","this","Grid_Body","Component","require","findNeighboursOfCell","xCoordinates","zip","allNeighbours","reduce","splice","validateNeighbour","bind","filter","aliveNeighboursCalculator","isAlive","calculateAliveNeighboursOfCell","nextGeneration","neighboursState","cells","Object","keys","aliveNeighboursOfEachCell","calculateAliveNeighbours","limits","concat","column","findAllNeighbours","allCells","rulesApplier","JSON","parse","nextGen","emptyGrid","getCopyOf","slice","World","_this","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","state","aliveCells","setState","forEach","_this$state","nextGenerationAliveCells","updateState","setInterval","evolve","event","targetIdArr","target","split","newAliveCells","console","log","Grid","addAliveCell","React","ReactDOM","render","src_World","document","getElementById"],"mappings":"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","file":"static/js/main.0e95ce9d.chunk.js","sourcesContent":["const zipper = function(yCoordinates) {\n    return function(result, element) {\n      for (let index = 0; index < yCoordinates.length; index++) {\n        result.push([element, yCoordinates[index]]);\n      }\n      return result;\n    };\n  };\n  \n  const validateNeighbours = function(bounds, neighbour) {\n    let startPoint = bounds.topLeft;\n    let endPopint = bounds.bottomRight;\n    let isValid = neighbour[0] >= startPoint[0] && neighbour[0] <= endPopint[0];\n    isValid =\n      isValid && neighbour[1] >= startPoint[1] && neighbour[1] <= endPopint[1];\n    return isValid;\n  };\n  \n  const contains = function(currentGeneration, neighbour) {\n    let isContained = currentGeneration.some(function(cell) {\n      return cell[0] === neighbour[0] && cell[1] === neighbour[1];\n    });\n    return isContained;\n  };\n  \n  module.exports = { zipper, validateNeighbours, contains };\n  ","import React, { Component } from 'react';\nimport './main.css';\n\nconst Data = function(props) {\n  const { element, rowIndex, columnIndex } = props;\n  return <td className={\"color-\"+element} id={rowIndex + ',' + columnIndex}></td>;\n};\n\nconst Row = function(props) {\n  const { row, rowIndex } = props;\n  return (\n    <tr>\n      {row.map((element, index) => (\n        <Data element={element} rowIndex={rowIndex} columnIndex={index} />\n      ))}\n    </tr>\n  );\n};\n\nconst Body = function(props) {\n  const { grid } = props;\n  return (\n    <tbody>\n      {grid.map((row, index) => (\n        <Row row={row} rowIndex={index} />\n      ))}\n    </tbody>\n  );\n};\n\nclass Table extends Component {\n  render() {\n    return (\n      <table className=\"grid\" id=\"grid\" onClick={this.props.onClick}>\n        <Body grid={this.props.grid} />\n      </table>\n    );\n  }\n}\n\nexport default Table;\n","const { zipper, validateNeighbours, contains } = require(\"./gameOfLifeUtils.js\");\n\nconst findNeighboursOfCell = function(cell, bounds) {\n  let xCoordinates = [cell[0] - 1, cell[0], cell[0] + 1];\n  let yCoordinates = [cell[1] - 1, cell[1], cell[1] + 1];\n  let zip = zipper(yCoordinates);\n  let allNeighbours = xCoordinates.reduce(zip, []);\n  allNeighbours.splice(4, 1);\n  let validateNeighbour = validateNeighbours.bind(null, bounds);\n  let allValidNeighbours = allNeighbours.filter(validateNeighbour);\n  return allValidNeighbours;\n};\n\nconst findAllNeighbours = function(bounds) {\n  let limits = bounds[\"bottomRight\"].concat(bounds[\"topLeft\"]);\n  let allNeighbours = {};\n  for (let row = limits[2]; row <= limits[0]; row++) {\n    for (let column = limits[3]; column <= limits[1]; column++) {\n      allNeighbours[\"[\" + row + \", \" + column + \"]\"] = findNeighboursOfCell(\n        [row, column],\n        bounds\n      );\n    }\n  }\n  return allNeighbours;\n};\n\nconst calculateAliveNeighboursOfCell = function(\n  allNeighbours,\n  currentGeneration,\n  cell\n) {\n  let isAlive = contains.bind(null, currentGeneration);\n  return allNeighbours[cell].filter(isAlive).length;\n};\n\nconst aliveNeighboursCalculator = function(allNeighbours, currentGeneration) {\n  return function(result, cell) {\n    result[cell] = calculateAliveNeighboursOfCell(\n      allNeighbours,\n      currentGeneration,\n      cell\n    );\n    return result;\n  };\n};\n\nconst calculateAliveNeighbours = function(allNeighbours, currentGeneration) {\n  let cells = Object.keys(allNeighbours);\n  let aliveNeighboursOfEachCell = aliveNeighboursCalculator(\n    allNeighbours,\n    currentGeneration\n  );\n  let neighboursState = cells.reduce(aliveNeighboursOfEachCell, {});\n  return neighboursState;\n};\n\nconst applyRules = function(neighboursState, currentGeneration, cell) {\n  let isAlive = neighboursState[cell] === 3;\n  isAlive =\n    isAlive ||\n    (neighboursState[cell] === 2 &&\n      contains(currentGeneration, JSON.parse(cell)));\n  return isAlive;\n};\n\nconst nextGeneration = function(currentGeneration, bounds) {\n  let allNeighbours = findAllNeighbours(bounds);\n  let neighboursState = calculateAliveNeighbours(\n    allNeighbours,\n    currentGeneration\n  );\n  let allCells = Object.keys(neighboursState);\n  let rulesApplier = applyRules.bind(null, neighboursState, currentGeneration);\n  let nextGen = allCells.filter(rulesApplier);\n  nextGen = nextGen.map(cell => JSON.parse(cell));\n  return nextGen;\n};\n\nexport {\n  findNeighboursOfCell,\n  findAllNeighbours,\n  calculateAliveNeighbours,\n  nextGeneration\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport Grid from './Grid.js';\nimport { nextGeneration } from './models/gameOfLife';\n\nconst emptyGrid = [\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n];\n\nconst getCopyOf = grid => grid.map(row => row.slice());\n\nclass World extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      grid: getCopyOf(emptyGrid),\n      aliveCells: [[4, 4], [4, 5], [5, 5]],\n      bounds: {\n        topLeft: [0, 0],\n        bottomRight: [9, 9]\n      }\n    };\n  }\n\n  updateState(aliveCells) {\n    this.setState(() => {\n      const grid = getCopyOf(emptyGrid);\n\n      aliveCells.forEach(cell => {\n        grid[cell[0]][cell[1]] = 1;\n      });\n\n      return { grid, aliveCells };\n    });\n  }\n\n  evolve() {\n    const { aliveCells, bounds } = this.state;\n    const nextGenerationAliveCells = nextGeneration(\n      getCopyOf(aliveCells),\n      bounds\n    );\n    this.updateState(getCopyOf(nextGenerationAliveCells));\n  }\n\n  componentDidMount() {\n    setInterval(this.evolve.bind(this), 1000);\n  }\n\n  addAliveCell(event) {\n    const targetId = event.target.id;\n    const targetIdArr = targetId.split(',');\n    const cell = [+targetIdArr[0], +targetIdArr[1]];\n    const { aliveCells } = this.state;\n    const newAliveCells = getCopyOf(aliveCells);\n    newAliveCells.push(cell);\n    console.log(newAliveCells);\n    this.setState({ aliveCells: getCopyOf(newAliveCells) });\n  }\n\n  render() {\n    return (\n      <Grid grid={this.state.grid} onClick={this.addAliveCell.bind(this)} />\n    );\n  }\n}\n\nReactDOM.render(<World />, document.getElementById('root'));\n"],"sourceRoot":""}